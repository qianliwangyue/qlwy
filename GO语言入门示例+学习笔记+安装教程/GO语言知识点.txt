go语言函数的左大括号 "{" 必须和函数名在同一行，否则会报错！！
*************		log.Fatal()有错误，则直接终止程序
测试竞态：			go run -race 竞态.go  
===================================================================================
导入包时可起别名：
import haha ”os“		//给包”os“起别名
import ”haha“		//使用包别名

===================================================================================
%T  数据的类型    用法和c语言&%相同 

nil 	 nil是预定义的标识符，代表指针、通道、函数、接口、映射或切片的0值 ，也就是预定义好的一个变量



************************************************************************************
go语言		cmd运行时，死循环 用crit+c 停止运行
cd..		返回上一级目录
cd 文件名	进入下一级文件

调用另一个文件的函数时，go run 两个文件名即可
列如：jinjie/1    1为包，一个包里只能有一个main函数入口，整个包看作一个完整的文件。
************************************************************************************

fmt.Printf("%c[%d;%d;%dm   字体写入位置   %c[0m\n", 0x1b, 1, 47, 34, 0x1b)
fmt.Printf("%c[%d;%d;%dm   %s   	     %c[0m\n", 0x1b, 1, 47, 34, "字体写入位置", 0x1b)

//注意字符串要写在%dm和%c之间，换行符要放在双引号最后："......\n"
//0，1，4，5，7，8/40~47/30~37：注意后两色一样时字体看不见eg：41，31
//0终端默认设置，1高亮显示，4使用下划线，5闪烁，7反白显示（字体和背景色交换），8不可见
//字体：	30，31，32，33，34， 35， 36，37
//背景色：	40，41，42，43，44， 45， 46，47
//		黑，红，绿，黄，蓝，紫红，青蓝，白
************************************************************************************

1 build flags
2 go build
3 go clean
4 go doc
5 go env			
6 go fix
7 go fmt
8 go generate
9 go get
10 go install
11 go list
12 go mod
13 go run
14 go test
15 go version
16 go vet






1 build flags
以下构建标志由build, clean, get, install, list, run, test 命令共有：
-a：强制重建已经是最新的软件包，在 Go 版本中，不适用于标准库；
-n：打印编译期间所用到的命令，但是并不真正执行它们;
-pn：可以并行运行的构建数量，在默认情况下，该数量等于CPU的逻辑核数；
-race：启用数据竞争检测，仅支持 linux/amd64、freebsd/amd64、darwin/amd64 和 windows/amd64；
-v：在编译时打印包的名称；
-work：打印出编译时生成的临时工作目录的路径，并在编译结束时保留它。在默认情况下，编译结束时会删除该目录；
-x：打印编译期间所用到的其它命令;
-ccflags：‘参数列表’，传递给每个 5c、6c 或 8c 编译器调用的参数；
-compiler name：要使用的编译器名称，如runtime.Compiler（gccgo 或gc）；
-gccgoflags ‘arg list’：传递给每个 gccgo 编译器/链接器调用的参数；
-gcflags ‘arg list’：每个 5g、6g 或 8g 编译器调用时传递的参数；
-installsuffix suffix：在包安装目录的名称中使用的后缀，以便将输出与默认构建分开；如果使用 -race 标志，安装后缀将自动设置为 Race，或者如果明确设置，则附加 _race；
-ldflags ‘flag list’：传递给每个 5l、6l 或 8l 链接器调用的参数；
-tags ‘tag list’：在构建过程中要考虑满足的构建标签列表。
列表标志接受以空格分隔的字符串列表，要在列表元素中嵌入空格，请用单引号或双引号将其括起来。
2 go build
用法：go build [build flags] [packages]
go build 命令用于编译我们指定的源码文件或代码包以及它们的依赖包。
如果我们在执行 go build 命令时不后跟任何代码包，那么命令将试图编译当前目录所对应的代码包。
go build 命令既不能编译包含多个命令源码文件的代码包，也不能同时编译多个命令源码文件，因为此时会包括多个main函数，显示函数重命名错误。
go build 本地代码包路径只能以目录相对路径的形式呈现，而不能使用目录绝对路径，即只能用./或…/或是直接当前包开始。
go build 构建标志：
-o name：标记可以指定输出文件的名称；
-i：安装那些编译目标依赖的且还未被安装的代码包;
3 go clean
用法：go clean [build flags] [packages]
go clean 命令会删除掉执行其它命令时产生的一些文件和目录，go 命令会在临时目录中构建对象，因此 go clean 主要关注其他工具或手动调用 go build 留下的对象文件。
go clean 从与导入路径对应的每个源目录中删除以下文件：
_obj/：Makefile 留下的旧的对象目录；
_test/：Makefile 留下的旧的测试目录；
_testmain.go：Makefile 留下的旧的gotest文件；
test.out：Makefile 留下的旧的测试日志；
build.out：Makefile 留下的旧的构建日志；
*.[568ao]：Makefile 留下的旧的对象文件；
DIR(.exe)：go build 生成的可执行文件，dir为最底层文件夹名；
DIR.test(.exe)：go test -c 生成的可执行文件；
MAINFILE(.exe)：go build MAINFILE.go 生成的文件；
*.so：SWIG生成的文件；
go clean 构建标志：
-i：删除安装当前代码包时所产生的结果文件，即bin或pkg下的文件；
-r：标以递归方式应用于由导入路径命名的包的所有依赖项；
-cache：删除整个 go build 缓存；
-testcache：使 go build 缓存中的所有测试结果过期；
-modcache：删除整个模块下载缓存，包括版本化依赖项的解压缩源代码。
4 go doc
用法：go doc [doc flags] [package|[package.]symbol[.methodOrField]]
go doc
go doc
go doc [.]
go doc [.][.]
go doc [.][.]
go doc 打印与由其参数（包、const、func、类型、var、方法或结构字段）标识的项目相关联的文档注释。
在所有形式中，当匹配符号时，参数中的小写字母匹配任一大小写，但大写字母完全匹配。这意味着如果不同的符号具有不同的大小写，则包中可能存在多个小写参数的匹配项。如果发生这种情况，则会打印所有匹配项的文档。
go doc 文档标志：
-all：显示所有的包文档；
-c：匹配时遵循大小写规则；
-cmd：像对待常规包一样对待命令（包 main），否则当显示包的顶级文档时，包 main 的导出符号被隐藏；
-short：用一行来显示；
-src：显示符号的完整源代码，这会显示其声明的完整 Go 源代码和定义，如函数定义、类型声明或封闭 const 堵塞；
-u：显示未导出和导出的文档符号、方法和字段；
-src：附加查看源码；
-ex：附加查看用例；
cmd/：查看可执行文件go的文档；
-goroot=“”：定制一个go语言根目录，在该目录下查找代码包文档，仅限于当次命令；
-http=:6060：查看HTML格式的文档，启动的Web服务器使用本机的6060端口，然后在址栏中输入http://localhost:6060来查看以网页方式展现的Go文档；
-index：在网页浏览模式下开启索引；
-q：开启远程查询功能；
godoc -q -server=“ip:port” pkg：启动go文档的web服务器后，则可以在远程指定ip和端口查询指定包。
5 go env
用法：go env [flag] [var …]
go env 用于打印Go语言的环境信息。
go doc 标志：
-json：标志以 JSON 格式而不是作为 shell 脚本打印环境。
-u：标志需要一个或多个参数，并取消命名环境变量的默认设置，如果已使用 ‘go env -w’ 设置的话。
-w：标志需要一个或多个 NAME=VALUE 形式的参数，并将命名环境变量的默认设置更改为给定值。
go env 相关打印信息：
CGO_ENABLED：指明cgo工具是否可用的标识；
GOARCH：程序构建环境的目标计算架构；
GOBIN：存放可执行文件的目录的绝对路径；
GOCHAR：程序构建环境的目标计算架构的单字符标识；
GOEXE：可执行文件的后缀，非win系统为空；
GOHOSTARCH：程序运行环境的目标计算架构；
GOOS：程序构建环境的目标操作系统；
GOHOSTOS：程序运行环境的目标操作系统；
GOPATH：工作区目录的绝对路径；
GORACE：用于数据竞争检测的相关选项；
GOROOT：Go语言的安装目录的绝对路径；
GOTOOLDIR：Go工具目录的绝对路径；
6 go fix
用法：go fix [packages]
go fix 命令把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码。
go fix 其实是 go tool fix 的简单封装，会先对作为参数的代码包导入路径进行验证，以确保它是正确有效的，然后把有效代码包中的所有Go语言源码文件作为多个参数传递给 go tool fix 命令。
go fix 命令参数：
-diff：不将修正后的内容写入文件，而只打印修正前后的内容的对比信息到标准输出。
-r：只对目标源码文件做有限的修正操作，该标记的值即为允许的修正操作的名称，多个名称之间用英文半角逗号分隔。
-force：即使源码文件中的代码已经与Go语言的最新版本相匹配了，也会强行执行指定的修正操作。该标记的值就是需要强行执行的修正操作的名称，多个名称之间用英文半角逗号分隔。
7 go fmt
用法：go fmt [-n] [-x] [packages]
go fmt file.go：将go程序格式化，自动对齐、空格等。
8 go generate
用法：go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go… | packages]
go generate ⽣成由现有⽂件中的指令描述的运⾏命令。这些命令可以运⾏任何进程，但⽬的是创建或更新 Go 源文件。
9 go get
用法：go get [-d] [-t] [-u] [-v] [build flags] [packages]
go get 根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。
go get 下载的依赖包一般在 $GOPATH/src下，如果指定了多个 $GOPATH，则在第一个 $GOPATH的src下。
go get 命令在检出代码包之前必须要知道代码包远程导入路径所对应的版本控制系统和远程仓库的URL。
go get 所支持的代码版本控制系统vcs有：
hg：Mercurial；
git：Git；
svn：Subversion；
bzr：Bazaar；
go get 命令包含了build和install操作，所以可以接收两者所有的命令参数，另外其特有的命令参数有：
-d：让命令只执行下载动作，而不执行安装动作；
-fix：让命令在下载代码包后先执行修正动作，而后再进行编译和安装。fix 工具可以修复因Go语言规范变更而造成的语法级别的错误；
-t：开始考虑构建命令⾏上指定的包的测试所需的模块；
-u：让命令利用网络来更新已有代码包及其依赖包。默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包；
-u=patch：指示 get 更新依赖项，但更改默认值以选择补丁版本。
go get 内置了代码包多版本依赖管理功能，在使用它检出或更新代码包之后，它会寻找与本地已安装Go语言的版本号相对应的标签（tag）或分支（branch）。如果没有找到指定的标签或者分支，则将本地代码包的版本切换到主干的最新版本。
10 go install
用法：go install [build flags] [packages]
go install 用于编译并安装指定的代码包及它们的依赖包。
go install 命令只比 go build 命令多做了一件事，即：安装编译后的结果文件到结果文件存放的目录，一般是GOBIN目录，即 $GOPATH/bin。
go install 只有在安装命令源文件时，才会在程序内部给代表其结果文件存放目录的变量赋值；在安装库源码文件时该值依然是空值。
11 go list
用法：go list [-f format] [-json] [-m] [list flags] [build flags] [packages]
go list 列出命名的包，每⾏⼀个，需要以代码包导入路径的方式给定代码包。
标志解析：
-f：标志使⽤包模板的语法指定列表的替代格式；
-json：标志使包数据以 JSON 格式打印，⽽不是使⽤模板格式；
-m：标志导致 list 列出模块⽽不是包；
-e：以容错模式加载和分析指定的代码包；
12 go mod
用法：go mod [arguments]
go mod 命令：
download：下载模块到本地缓存；
edit：从工具或脚本编辑go.mod；
graph：打印模块需求表；
init：在当前目录初始化一个新的模块
tidy：添加丢失的模块并删除未使用的模块；
vendor：制作依赖项的副本；
verify：验证依赖项是否有预期内容；
why：解释模块或包为什么需要；
go mod download [-x] [-json] [modules]：下载命名的模块，可以是模块模式选择主模块的依赖关系，也可以是 path@version 形式的模块查询。没有参数时，下载适⽤于主模块的所有依赖项（相当于“go mod download all”）。
-json ：将⼀系列 JSON 对象打印到标准输出，描述每个下载的模块，对应于这个 Go 结构：
type Module struct {
    Path     string //模块路径
    Version  string //模块版本
    Error    string //模块加载错误
    Info     string //.info缓存文件的绝对路径
    GoMod    string //.mod缓存文件的绝对路径
    Zip      string //.zip缓存文件的绝对路径
    Dir      string //缓存根目录的绝对路径
    Sum      string //路径、版本的校验和
    GoModSum string //go.mod 的校验和
}


-x：打印下载执⾏的命令；
go mod edit [editing flags] [-fmt|-print|-json] [go.mod]：提供了⼀个⽤于编辑 go.mod 的命令⾏界⾯，主要供⼯具或脚本使⽤。它只读取 go.mod，不查找有关模块的信息。
编辑标志指定编辑操作的序列：
-module：更改模块的路径；
-require=path@version 和 -droprequire=path：添加或删除给定路径和版本的模块到需求项；
-exclude=path@version 和 -dropexclude=path@version：添加或删除给定路径和版本的模块到排除项；
-replace=old[@v]=new[@v]：替换给定路径和版本的模块；
-dropreplace=old[@v]：丢弃给定模块路径和版本对的替换；
-go=version：设置预期的 Go 语⾔版本；
-fmt ：重新格式化 go.mod ⽂件⽽不进⾏其他更改；
-print 标志以其⽂本格式打印最终的 go.mod；
-json 标志以 JSON 格式打印最终的 go.mod ⽂件；
go mod graph [-go=version]：以文本形式打印模块需求表；
go mod init [module-path]：在当前⽬录中初始化并写⼊⼀个新的 go.mod ⽂件，实际上创建了⼀个以当前⽬录为根的新模块。
go.mod ⽂件必须不存在；
接受⼀个可选参数，即新模块的模块路径；
如果省略了模块路径参数，go init 将尝试使⽤ .go ⽂件、 vendoring ⼯具配置⽂件（如 Gopkg.lock）和当前⽬录（如果在 GOPATH 中）中的导⼊注释来推断模块路径。
go mod tidy [-e] [-v] [-go=version] [-compat=version]：它添加构建当前模块的包和依赖项所需的任何缺失模块，并删除不提供任何相关包的未使⽤模块；它还向 go.sum 添加任何缺失的条⽬并删除任何不必要的条⽬。
-v：将有关已删除模块的信息打印到标准错误；
-e：遇到错误时继续尝试加载包；
go mod vendor [-e] [-v]：供应商重置主模块的供应商⽬录以包含构建和测试所有主模块的包所需的所有包。
参数同上；
13 go run
用法：go run [build flags] [-exec xprog] package [arguments…]
go run 命令可以编译并运行命令源码文件，并把编译后的可执行文件存放到临时工作目录。
go run 命令只接受Go源码文件作为参数，而不接受代码包，更不接收测试文件。
go run 命令也不允许多个命令源码文件作为参数，即使它们在同一个代码包中也是如此，因为多个命令源码文件都有相同的main函数声明。
命令源码文件如果可以接受参数，则可以在执行 go run 命令运行这个命令源码文件时把参数名和参数值成对的追加在后面，go run 命令会把参数原封不动的传给对应的可执行文件。
-exec：将使⽤ xprog 调⽤⼆进制⽂件；
14 go test
用法：go test [build/test flags] [packages] [build/test flags & test binary flags]
go test 命令用于以代码包为单位对Go语言编写的程序进行测试。
测试源码文件是名称以“_test.go”为后缀的，内含若干测试函数的源码文件。测试函数一般是以“Test”为名称前缀并有一个类型为“testing.T”的参数声明的函数。
一般情况下，我们会把测试源码文件与被测试的源码文件放在同一个代码包中。并且，这些源码文件中声明的包名也都是相同的。
go test 以下参数：
-c：生成用于运行测试的可执行文件，但不执行它；
-i: 安装/重新安装运行测试所需的依赖包但不编译和运行测试代码；
go test 中的以下相关函数可以在测试函数中通过t.fun…方式执行：
func (t *T) Fail()：标记测试函数失败，但仍然继续执行；
func (t *T) FailNow()：标记测试函数失败，并中断其执行，然后执行下一文件中的测试函数；
func (t *T) Log(args… interface{})：用默认格式对其参数进行格式化，与 Print() 类似，并且记录文本到错误日志；
func (t *T) Fatal(args… interface{})：等价于Log()后跟随FailNow()；
15 go version
go version [-m] [-v] [file …]：打印 Go 可执⾏⽂件的构建信息。
如果命令⾏上没有指定⽂件，go version 会打印⾃⼰的版本信息。
-v：报告⽆法识别的⽂件。
-m：使 go version 在可⽤时打印每个可执⾏⽂件的嵌⼊式模块版本信息。
16 go vet
用法：go vet [-n] [-x] [-vettool prog] [build flags] [vet flags] [packages]
go vet 用于检查Go语言源码中静态错误的简单工具。
go vet 依然支持-n、-x命令参数，另外还有：
-all：进行全部检查；
-assign：检查赋值语句；
print：检查打印函数是否使用正确；
methods：检查标准命名方法的签名；
……
go vet 能够捕获的错误有：
Printf 类函数调用时，类型匹配错误的参数；
定义常用的方法时，方法签名的错误；
错误的结构标签；
没有指定字段名的结构字面量；




数据类型

1.	2-10

二进制转化十进制

eg: 	1101					

1*2^3 + 1*2^2 + 0*2^1 + 1*2^0
=8+4+0+1
=13



十进制转化二进制

		  余
13/2	  	6……1
6/2		3……0
3/2		1……1
1/2		0……1


余数从下往上读：1101

==========================================================================================================================================



2. 8-10

八进制转化十进制

eg: 16

1*8^1 + 6*8^0
=8+6
=14


十进制转化八进制
		  余
14/8		1……6
1/8		0……1

余数从下往上读：16


==========================================================================================================================================
3. 8-16

八进制转化十六进制
8->10->16
16->10->8







int 	有符号整型
uint 	无符号整型


范围计算

eg:
int 8
  
二进制转换为十进制
01111111->255
10000000->-128
减1取反



int 16
0111111111111111->2^16-1


int						-2^31~2^31-1
int 8						7~128
int 16					768~-32767
int 32					47483648~-2147483647
int 64 					63~-2^63-1



uint 8					255
uint 16					2^16-1
uint 32					2^31-1
uint 64					2^63-1




rune  有符号					^31~2^31-1
byte  无符号	     等价于uint8		0~255              









float32		4字节			-3.403E38~3.403E38
float64		8字节			-1.798E308~1.798E308
			


complex32	32位实数和虚数	
complex64	64位实数和虚数




uintptr	无符号整型，用于存放一个指针



	二、转义符

type Human struct {
Name string
}
var people = Human{Name:"zhangsan"}

1）普通占位符
		占位符	说明	举例	输出
		%v	相应值的默认格式。	Printf("%v", people)	{zhangsan}
		%+v	打印结构体时，会添加字段名	Printf("%+v", people)	{Name:zhangsan}
		%#v	相应值的Go语法表示	Printf("#v", people)	main.Human{Name:"zhangsan"}
		%T	相应值的类型的Go语法表示	Printf("%T", people)	main.Human
		%%	字面上的百分号，并非值的占位符	Printf("%%")	%
2）布尔占位符
		占位符	说明	举例	输出
		%t	true 或 false	Printf("%t", true)	true
3）整数占位符
		占位符	说明	举例	输出
		%b	二进制表示	Printf("%b", 5)	101
		%c	相应Unicode码点所表示的字符	Printf("%c", 0x4E2D)	中
		%d	十进制表示	Printf("%d", 0x12)	18
		%o	八进制表示	Printf("%d", 10)	12
		%q	单引号围绕的字符字面值，由Go语法安全地转义	Printf("%q", 0x4E2D)	'中'
		%x	十六进制表示，字母形式为小写 a-f	Printf("%x", 13)	d
		%X	十六进制表示，字母形式为大写 A-F	Printf("%x", 13)	D
		%U	Unicode格式：U+1234，等同于 "U+%04X"	Printf("%U", 0x4E2D)	U+4E2D
4）浮点数和复数的组成部分（实部和虚部）
		占位符	说明	举例	输出
		%b	无小数部分的，指数为二的幂的科学计数法， 与 strconv.FormatFloat 的 'b' 转换格式一致。例如 -123456p-78		
		%e	科学计数法，例如 -1234.456e+78	Printf("%e", 10.2)	1.020000e+01
		%E	科学计数法，例如 -1234.456E+78	Printf("%e", 10.2)	1.020000E+01
		%f	有小数点而无指数，例如 123.456	Printf("%f", 10.2)	10.200000
		%g	根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出	Printf("%g", 10.20)	10.2
		%G	根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出	Printf("%G", 10.20+2i)	(10.2+2i)
5)字符串与字节切片
		占位符	说明	举例	输出
		%s	输出字符串表示（string类型或[]byte)	Printf("%s", []byte("Go语言"))	Go语言
		%q	双引号围绕的字符串，由Go语法安全地转义	Printf("%q", "Go语言")	"Go语言"
		%x	十六进制，小写字母，每字节两个字符	Printf("%x", "golang")	676f6c616e67
		%X	十六进制，大写字母，每字节两个字符	Printf("%X", "golang")	676F6C616E67
6)指针
		占位符	说明	举例	输出
		%p	十六进制表示，前缀 0x	Printf("%p", &people)	0x4f57f0
7)其它标记
		占位符	说明	举例	输出
		+	总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。	Printf("%+q", "中文")	"\u4e2d\u6587"
		-	在右侧而非左侧填充空格（左对齐该区域）		
		#	备用格式：为八进制添加前导 0（%#o） 为十六进制添加前导 0x（%#x）或 0X（%#X），为 %p（%#p）去掉前导 0x； 如果可能的话，%q（%#q）会打印原始 （即反引号围绕的）字符串； 如果是可打印字符，%		U（%#U）会写出该字符的 Unicode 编码形式（如字符 x 会被打印成 U+0078 'x'）。	Printf("%#U", '中')	U+4E2D
		' '	(空格)为数值中省略的正负号留出空白（% d）； 以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开		
		0	填充前导的0而非空格；对于数字，这会将填充移到正负号之后	





	
8）其他
		golang没有 '%u' 点位符，若整数为无符号类型，默认就会被打印成无符号的。

宽度与精度的控制格式以Unicode码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。
操作数的类型为int时，宽度与精度都可用字符 '*' 表示。

对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印123.5，（而 %6.2f 会打印123.45）。

%e 和 %f 的默认精度为6

对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。

而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。

2、了解了基本的占位符对应什么格式就要使用占位符了
使用起来很简单，一般配合fmt.Printf()使用，因为fmt的Printf()是有格式的输出，切忌使用Println()，否则将会以字符串的形式输出。




A = 0011 1100

B = 0000 1101

-----------------

A&B = 0000 1100

A|B = 0011 1101

A^B = 0011 0001




运算符	描述	实例
&	按位与运算符"&"是双目运算符。 其功能是参与运算的两数各对应的二进位相与。	(A & B) 结果为 12, 二进制为 0000 1100
|	按位或运算符"|"是双目运算符。 其功能是参与运算的两数各对应的二进位相或	(A | B) 结果为 61, 二进制为 0011 1101
^	按位异或运算符"^"是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。	(A ^ B) 结果为 49, 二进制为 0011 0001
<<	左移运算符"<<"是双目运算符。左移n位就是乘以2的n次方。 其功能把"<<"左边的运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。	A << 2 结果为 240 ，二进制为 1111 0000
>>	右移运算符">>"是双目运算符。右移n位就是除以2的n次方。 其功能是把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数。	A >> 2 结果为 15 ，二进制为 0000 1111



